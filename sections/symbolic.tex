% !TEX root=../main.tex

\subsection{Symbolic execution}

Previous work introduces a symbolic execution semantics for \TOPHAT\ programs~\cite{conf/ifl/NausSK19}.
\todo{moeten we hier jou en/of mijn proefschrift ook nog citen? Zie ook beneden}
By defining semantic rules that introduce symbols where user input is expected, the behaviour of a \TOP\ program can be fully described.
This symbolic behaviour description can then be used to reason over the properties of the program.
\cref{fig:symbolic-semantics} lists a selected number of symbolic execution rules.
\todo{insert rules and describe them in some level of detail.}

\begin{figure}[h]
    TODO TODO TODO
    \caption{Examples of symbolic execution rules for \TOPHAT}
    \label{fig:symbolic-semantics}
\end{figure}

Ultimately, the symbolic execution of a \TOPHAT\ program is then powered by a top-level simulation function, that leverages the symbolic rules to perform symbolic execution.
Since a user can update an editor as often as they want, special care is taken to ensure that only \textit{productive} updates are generated by the symbolic execution function.
An editor can only be updated twice, if the task, modulo the updated value, has changed.
This allows exactly enough repetition to capture the full program behaviour.
For example, the second task in a parallel composition might rely on a value being updated in the first task, to make progress.
\todo{wil je hier ook de simulate functie laten zien?}

When it comes to \DYNTOPHAT, there is an additional opportunity for infinite interaction, namely to spool up a new task.
Unfortunately, in this case, there is no way to set an upper bound on this interaction without changing the program's behaviour.
Imagine we have a task pool combinator, followed by a step.
We restrict the number of new task initializations to be no larger than some $n$.
The step could very well require $n+1$ values before it will allow a step.
It is clear from this example that limiting task initialization is not a suitable way to deal with the infinite interaction coming from the pool combinator.

The pool combinator breaks traditional symbolic execution as introduced in previous work~\cite{conf/ifl/NausSK19}.
That does not mean that the symbolic execution of \DYNTOPHAT\ programs is now completely useless.
Built on top of the symbolic execution engine, \citet{conf/sfp/NausS20} presents a system that assists users of \TOPHAT\ programs in finding the next input action to perform.
The basic idea is that symbolic execution can be leveraged to reach some goal $\psi$.
\cref{fig:next-step-hint} defines a function that calculates these so-called next-step-hints.

\begin{figure}[h]
  \begin{mathpar}
    \usemacro{O-Hints}
  \end{mathpar}
  \caption{Next-step hint generation function}
  \label{fig:next-step-hint}
\end{figure}


\todo{explain the function in this figure, and how it uses symbolic execution.}

The addition of a symbolic execution rule for the task pool combinator breaks the definition from \cref{fig:next-step-hint}, since the symbolic interaction \textit{traces} are now potentially infinite.
\todo{add a symbolic rule for task pool combinator}
Instead of calculating all possible hints, one could alter the hints function to perform a breadth-first search through the now infinite trace space.
This allows us to return a hint that guides the user to the shortest path to their goal.
\cref{fig:next-step-hint-pool} lists an updated definition of the next-step hint function.

\begin{figure}[h]
    TODO TODO TODO
    \caption{Next-step hint generation function}
    \label{fig:next-step-hint-pool}
\end{figure}

Coming back to reasoning about task properties, the breadth-first search strategy can also be applied to finding assertion violations.
\citet{DBLP:conf/tap/NausVSR23} demonstrate a breadth-first search approach to finding assertion violations in low-level programs with potential infinite search spaces.
This approach can also be applied to \DYNTOPHAT\ programs, using the insights described above.

To conclude, adding task pools to \TOPHAT\ does restrict the use of symbolic execution, but it still has several viable applications.
These restrictions are similar to those found with any real-world application of symbolic execution.
A more extensive discussion on this point can be found elsewhere~\cite{conf/ifl/NausSK19}.