% !TEX root=../main.tex

\section{Dynamic TopHat}
\label{sec:dyntophat}

% \subsection{Language}

Although it is possible in \TOPHAT\ to start multiple tasks in parallel,
the amount of these tasks needs to be known in advance by the programmer.
Let us illustrate this with an example.

\begin{example}[Vending machine with shared stock]
  \label{exm:vending-shared}
  Take this slightly more complex vending machine,
  where two buyers can purchase a $\Snack$ at the same time from a shared inventory.

  \begin{TASK}[emph={inventory,payment}]
    let vend$_1$ : Task Snack = do inventory.
      enter Int >>? do payment.
      case payment of
        1 |-> decrease Biscuit inventory >>= do _.
             view Biscuit
        2 |-> decrease Chocolate inventory >>= do _.
             view Chocolate
        _ |-> fail
    let machine$_1$ : Task (Snack * Snack) =
      share [(Biscuit, 24), (Chocolate, 16)] >>= do inventory.
      vend$_1$ inventory <&> vend$_1$ inventory
  \end{TASK}

  Here \var{decrease} is a function that decreases the amount of the given snack by one in the shared list of snacks.
  Note that this task results in a pair containing the two bought $\Snack$s.

  We see that, at development time, we need to specify the number of \var{vend} tasks that can be done at the same time.
  Although in the physical world, it is quite evident that one can only place a predefined amount of vending machines next to each other,
  in the digital world, one would expect to initialise and kill such processes at any time.
\end{example}

To mitigate this problem in \TOPHAT,
we introduce \DYNTOPHAT.


\subsection{Task pools}

\DYNTOPHAT\ is a moderate extension to the \TOPHAT\ base language where we add support for \emph{task pools}.
Task pools contain zero or more instantiations of a \emph{template task} running in parallel.
In this regard, task pools are similar to the parallel-and combinator ($\Pair$).
End users can interact with all tasks currently running in a pool.
However, one can initiate a new instance of the template task by sending an \emph{init} event to the task pool.
Similarly, by sending a \emph{kill} event, the task pool terminates one of its children.

Language-wise, a task pool is a new combinator at the task level.
The combinator $\Pool^k_{t_0} []$ is parametrised by a unique key $k$, a template task $t_0$ and an (initially) empty task list $[]$.
Each time end users send an init action to this pool: $k\Send\Init$.
The template task is placed in the list of currently running tasks,
in this case resulting in $\Pool^k_{t_0} [t_0]$.
This way, an arbitrary amount of tasks can be started at runtime.
Tasks in the list can also be killed by sending a \emph{kill} action to the pool: $k\Send\Kill1$.
In this case, the first task in the pool will be killed.
The syntactic extensions to \TOPHAT\ are shown in \cref{fig:dynamic-grammar}.

\begin{figure}
  \usemacro{G-Dynamic-extensions}
  \caption{Grammar for \DYNTOPHAT\ extensions}
  \label{fig:dynamic-grammar}
\end{figure}

\begin{example}[Dynamic number of vending machines]
  \label{exm:vending-dynamic}
  Using the same \var{vend}$_1$ task from \cref{exm:vending-shared},
  we can now create a vending machine where end users can start an arbitrary amount of vending tasks.
  \begin{TASK}
    let machine$_2$ : Task (List Snack) =
      share [(Biscuit, 24), (Chocolate, 16)] >>= do ss.
      >&<$_{\var{vend}_1\,\var{ss}}$ []
  \end{TASK}
  Sending $\Init$ to above task creates a new \var{vend} task
  which will ask for an amount of money and will result in a \var{Biscuit} or \var{Chocolate}.
  Note that this machine, contrary to the one in \cref{exm:vending-shared}, will run indefinitely.
\end{example}


\subsection{Semantics}

Typing rules of task pools are given in \cref{fig:typing-dynamic}.
Here we simply state that a task pool results in a list of values.

\begin{figure}
  \begin{mathpar}
    \boxed{\RelationT} \\
    \userule{T-Pool} \\
  \end{mathpar}
  \caption{Typing rules for \DYNTOPHAT}
  \label{fig:typing-dynamic}
\end{figure}

Extensions of the dynamic semantics are given in \cref{fig:typing-dynamic}.
Similar how normalisation works for task pairing (as shown in \cref{fig:semantics-tophat}),
normalisation of task pools normalises each task in the pool and constructs a new pool.
Note that the template task is not normalised.
This means that, every time the template task is added to the task pool,
it will be normalised after this action.
Otherwise we would create unwanted sharing.
\todo{add bad sharing example?}
If, for example, the template needs to do some setups,

\todo{explaing extended handing semantics}

\begin{figure}
  \begin{mathpar}
    % \userule{E-Pool} \\
    \boxed{\RelationN} \\
    \userule{N-Pool-Name} \\
    \userule{N-Pool} \\
    \boxed{\RelationH} \\
    \userule{H-Init} \\
    \userule{H-Kill} \\
    \userule{H-Pool} \\
  \end{mathpar}
  \caption{Semantic rules for \DYNTOPHAT}
  \label{fig:semantics-dynamic}
\end{figure}

and extended observations in \cref{fig:observations-dynamic}.
\todo{explain observations}

\begin{figure}
  \usemacro{O-Dynamic}
  \caption{Observations for \DYNTOPHAT}
  \label{fig:observations-dynamic}
\end{figure}
