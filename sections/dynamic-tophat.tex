% !TEX root=../main.tex

\section{Dynamic TopHat}
\label{sec:dyntophat}

% \subsection{Language}

Although it is possible in \TOPHAT\ to start multiple tasks in parallel,
the amount of these task should be specified by the programmer at develop time.
Let us illustrate this with an example.

\begin{example}[Vending machine with shared stock]
  \label{exm:vending-shared}
  Take this slightly more complex vending machine,
  where two buyers can purchase a $\Snack$ at the same time from a shared inventory.

  \begin{TASK}[]
    let vend$_1$ : Task Snack = do ss.
      enter Int >>= do n.
      case n of
        1 |-> decrease Biscuit ss >>= do _.
             view Biscuit
        2 |-> decrease Chocolate ss >>= do _.
             view Chocolate
        _ |-> fail
    let machine$_1$ : Task (Snack * Snack) =
      share [(Biscuit, 24), (Chocolate, 16)] >>= do ss.
      vend$_1$ ss <&> vend$_1$ ss
  \end{TASK}

  Here \var{decrease} is a function that decreases the amount of the given snack by one in the shared list of snacks.
  Note that this task results in a pair containing the two bought $\Snack$s.
\end{example}

Here we see that, at development time, we need to specify the number \var{vend}s that can be done at the same time.
Although in the physical world, it is quite evident that one can only place a predefined amount of vending machines next to each other,
in the digital world, one would expect to initialise and kill such processes at any time.

\subsection{Task pools}

\DYNTOPHAT\ is a moderate extension to the \TOPHAT\ base language where we add support for \emph{task pools}.
Task pools contain zero or more instantiations of a \emph{template task} running in parallel.
In this regard, they are similar to the pair combinator ($\Pair$).
End users can interact with all tasks currently running in a pool.
However, one can initiate a new instance of the template task by sending an \emph{init} signal to the task pool itself.
Similarly, by sending a \emph{kill} signal, the task pool terminates one of its children.

In the \TOPHAT\ language, a task pool is a new combinator at the task level.
The combinator $\Pool^k_{t_0} []$ is parametrised by an unique key $k$, a template task $t_0$ and (initially) an empty task list $[]$.
Each time end users send an \emph{init} action to this pool ($k\Send\Init$),
the template task is placed in the list of current running tasks,
in this case resulting in $\Pool^k_{t_0} [t_0]$.
This way, an arbitrary amount of tasks can be started at runtime.
Tasks in the task list of a pool can also be killed by sending a \emph{kill} action to the pool ($k\Send\Kill1$).
In this case the first task in the pool will be killed.
The syntactic extensions to \TOPHAT\ are shown in \cref{fig:dynamic-grammar}.

\begin{figure}
  \usemacro{G-Dynamic-Ext}
  \caption{Grammar for \DYNTOPHAT}
  \label{fig:dynamic-grammar}
\end{figure}

\begin{example}[Dynamic number of vending machines]
  \label{exm:vending-dynamic}
  Using the same \var{vend}$_1$ task from \cref{exm:vending-shared},
  we can now create a vending machine where end users can start an arbitrary amount of vending tasks.
  \begin{TASK}
    let machine$_2$ : Task (List Snack) =
      share [(Biscuit, 24), (Chocolate, 16)] >>= do ss.
      >&<$_{\var{vend}_1\,\var{ss}}$ []
  \end{TASK}
  Sending $\Init$ to above task creates a new \var{vend} task
  which will ask for an amount of money and will result in a \var{Biscuit} or \var{Chocolate}.
  Note that this machine, contrary to the one in \cref{exm:vending-shared}, will run indefinitely.
\end{example}


\subsection{Semantics}

Typing rules of task pools are given in \cref{fig:typing-dynamic}.
Here we simply state that a task pool results in a list of values.

\begin{figure}
  \begin{mathpar}
    \boxed{\RelationT} \\
    \userule{T-Pool} \\
  \end{mathpar}
  \caption{Typing rules for \DYNTOPHAT}
  \label{fig:typing-dynamic}
\end{figure}

Extensions of the dynamic semantics are given in \cref{fig:typing-dynamic}.
Similar how normalisation works for task pairing (as shown in \cref{fig:semantics-tophat}),
normalisation of task pools normalises each task in the pool and constructs a new pool.
Note that the template task is not normalised.
This means that, every time the template task is added to the task pool,
it will be normalised after this action.
Otherwise we would create unwanted sharing.
\todo{add bad sharing example?}
If, for example, the template needs to do some setups,

\begin{figure}
  \begin{mathpar}
    % \userule{E-Pool} \\
    \boxed{\RelationN} \\
    \userule{N-Pool-Name} \\
    \userule{N-Pool} \\
    \boxed{\RelationH} \\
    \userule{H-Init} \\
    \userule{H-Kill} \\
    \userule{H-Pool} \\
  \end{mathpar}
  \caption{Semantic rules for \DYNTOPHAT}
  \label{fig:semantics-dynamic}
\end{figure}

and extended observations in \cref{fig:observations-dynamic}.
\todo{add observations}

\begin{figure}
  \usemacro{O-Dynamic}
  \caption{Observations for \DYNTOPHAT}
  \label{fig:observations-dynamic}
\end{figure}
