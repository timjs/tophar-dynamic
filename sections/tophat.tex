% !TEX root=../main.tex

\section{TopHat}
\label{sec:tophat}

\subsection{Language}

Here we describe the \TOPHAT\ language as presented in \citet{Steenvoorden22},
which slightly deviates from presentations in earlier work \cite{conf/ppdp/SteenvoordenNK19,conf/ifl/NausSK19,conf/sfp/NausS20}.

The \TOPHAT\ language consists of two layers: the expression layer and the task layer.
The expression layer is a \STLC\ with primitive types, pairs, lists and references.
We use pattern matching to project the fields of pairs.
% It's grammar can be found in \cref{fig:expr-grammar}.
%
The grammar of the task layer is given in \cref{fig:task-grammar}.
Tasks can either be editors or combinators.

\begin{figure}[h]
  \usemacro{G-Tasks}
  \caption{Task grammar}
  \label{fig:task-grammar}
\end{figure}

\paragraph{Editors}

Editors are the interaction points of a task program.
They are an abstraction over widgets or form input fields.
Editors are type safe,
they only accept values of their specified type.
The type of an editor can also be used to (generically) render a user interface.
For example,
an editor of type $\Bool$ could be rendered as a check box,
while end users could interact with an editor of type $\Location$ by putting a pin on a map.

Editors can initially be empty, or \emph{unvalued} ($\Enter^\nu \beta$).
After sending a value $b$ to an editor, the editor is \emph{valued} ($\Update^\nu b$).
The value of an editor can be changed by sending a new value.
They cannot be cleared.
Editors can also be declared as \emph{read-only} ($\View^\nu b$).
This way they show static information to an end user.

Shared editors $\Change^\nu h$ watch over a heap location $h$,
similar to \ML-style references.
Changing the value of shared editors,
changes the value in the heap location.
Multiple shared editors can watch the same heap location.
As plain editors, shared editors can also be read-only ($\Watch^\nu h$),
which means their displayed value will only change when the referenced heap location changes,
but the end user cannot send a value to update the heap location.

\begin{figure}[h]
  \input{figures/editors}
  \caption{Possible states of editors and its transitions}
  \label{fig:editor-state}
\end{figure}

\paragraph{Combinators}

Combinators unite smaller tasks into bigger ones.
The pair combinator ($t_1 \Pair t_2$) for example,
pairs two tasks so that both can be worked on concurrently.
The result thereof is a pair containing both the results of $t_1$ and $t_2$.
The choose combinator ($t_1 \Choose t_2$) on the other hand,
results in either the result of $t_1$ or $t_2$,
depending on which task first has a result.
To map a function over the value in a task,
one can use the transform task ($e_1 \Trans t_2$).

The most important combinator is the step combinator.
The task $t_1 \Step e_2$ decides when to transition from task $t_1$
to the task calculated by its continuation $e_2$.
The failing task $\Fail$ is used to signal a task that cannot be stepped to.
Also, it is the identity of the choose task.
Furthermore, one can create a shared heap location and assign to it.
The lift task is used to lift a value into the task domain.


\begin{example}[Vending machine]
  \label{exm:vending-base}
  The following example demonstrates the use of external communication and choice.
  We have a vending machine that dispenses a biscuit for one coin and a chocolate bar for two coins.
  % \begin{TASK}
  %   let vend : Task Snack = enter Int >>? do n. if n == 1 then view Biscuit
  %     else if n == 2 then view Chocolate else fail
  % \end{TASK}
  \begin{TASK}
    type Snack = [Biscuit, Chocolate]
    let vend$_0$ : Task Snack = enter Int >>? do n.
      case n of
        1 |-> view Biscuit
        2 |-> view Chocolate
        _ |-> fail
  \end{TASK}
  The editor $\Enter \Int$ asks the user to enter an amount of money.
  This editor stands for a coin slot in a real machine that freely accepts and returns coins.
  There is a continue button on the machine, which sends a continue event to the select combinator ($\Select$),
  which is a derived combinator acting similar to the previously mentioned step combinator.
  The button is initially disabled, due to the fact that the editor has no value.
  When the user has inserted exactly 1 or 2 coins, the continue button becomes enabled.
  When the user presses the continue button, the machine dispenses either a biscuit or a chocolate bar, depending on the amount of money.
  Other cases result in the failure task $\Fail$, which signals a path that cannot be followed.
  The vending machine stays in the state to accept and return money.
  Snacks are modelled using a custom type.
\end{example}

% \todo{shares}

\paragraph{Inputs}

Editors are the interaction leaves of task-oriented programs.
They are the only way users can interact with the system.
Each editor is keyed with an \emph{unique} key $k$.
Sending $k \Send b$ to the system will change the value inside the editor with key $k$ to hold value $b$.
\cref{fig:input-grammar} contains the grammar of inputs and actions accepted by a \TOPHAT\ system.

\begin{figure}[h]
  \usemacro{G-Inputs-compact}
  \caption{Input grammar}
  \label{fig:input-grammar}
\end{figure}


\paragraph{Types}

\cref{fig:typing-grammar} shows the grammar of types.
The typing rules of all tasks can be found in \cref{fig:typing-rules}.
Note that editors and references can only contain values of basic types $\beta$.
In particular, editors and references cannot contain functions or tasks themselves.
The reason for this restriction is twofold.
First, prohibiting references to functions keeps our language total.
This is necessary for the symbolic execution to not enter an infinite loop.
Second, restricting editors to only contain basic values
guarantees one can present these values to end users (print them)
and receive new inputs from end users (parse them).
Arbitrary tasks and functions do not have this property.

\begin{figure}[h]
  \usemacro{G-Types}
  \caption{Typing grammar}
  \label{fig:typing-grammar}
\end{figure}

\begin{figure}[h]
  % \small
  \begin{mathpar}
    \boxed{\RelationT}    \\
    \userule{T-Enter}     \quad
    \userule{T-Update}    \quad
    \userule{T-View}      \\
    \userule{T-Change}    \quad
    \userule{T-Watch}     \\
    \userule{T-Trans}     \\
    \userule{T-Pair}      \quad
    \userule{T-Lift}      \\
    \userule{T-Choose}    \quad
    \userule{T-Fail}      \\
    \userule{T-Step}      \\
    \userule{T-Share}     \quad
    \userule{T-Assign}
  \end{mathpar}
  \caption{Typing rules}
  \label{fig:typing-rules}
\end{figure}


\subsection{Semantics}

\TOPHAT\ semantics consist of three layers: the host layer, the internal layer, and the external layer.

\begin{figure}[h]
  \usemacro{P-Semantic-Layers}
  \caption{Semantic functions and their relation
    (read $x \bullet\!\!\raisebox{-0.1ex}{\mbox{â€“}}\ y$ as `$x$ makes use of $y$')}
  \label{fig:semantic-layers}
\end{figure}

\begin{itemize}
  \item
    The \emph{host layer} is responsible for evaluating expressions in our host language,
    the \STLC\ with basic types and references.
    This layer only contains big-step evaluation relation ($\evaluate$).
  \item
    The \emph{internal layer} only operates on tasks.
    It normalises tasks so that they can be presented to end users to interact with.
    This layer contains the big-step normalisation ($\normalise$) and fixation ($\fixate$) relations.
  \item
    The \emph{external layer} takes inputs from end users and rewrites tasks based on this input.
    This layer contains two labelled small-step handling ($\handle{\iota}$) and interaction ($\interact{\iota}$) relations.
\end{itemize}

Next to these semantic relations, \TOPHAT\ uses \emph{observations} on tasks to decide which semantic rule will fire.
These observations include, amongst others,
the value of a task,
if a task is failing or not,
and the set of possible inputs a task can handle.
\cref{fig:semantic-layers} shows an overview of all semantic relations and observations used in each layer.

\todo{Explain N and H rules}

\begin{figure}[h]
  \begin{mathpar}
    \boxed{\RelationN} \\
    \userule{N-Name} \\
    \userule{N-Pair} \\
    \boxed{\RelationH} \\
    \userule{H-Enter} \\
    \userule{H-Pair} \\
  \end{mathpar}
  \caption{Example of semantic rules for \TOPHAT}
  \label{fig:semantics-tophat}
\end{figure}
